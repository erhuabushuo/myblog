Title: 从零学密码学：十六、 寻找质数
Date: 2016-09-27 11:55
Category: Cryptology

到目前为止，我们所学过的所有加密法都已经存在数百年了，它们（除了一次一密加密法）全都很容易被计算机破译。这些加密法都能够很好地应对使用纸和笔进行破译的黑客，但计算机现在操作数据的速度远远超过人类使用纸和笔。RSA加密法相对于这些老实加密法有多处改善，这将在我们下一节讲述。然而，RSA加密法需要我们先了解质数。

## 质数

质数是大于1且只有1和它本身两个因数的整数。还记得吗？一个数字的因数是可以通过乘法得到原来的数字的数字。
数字3和7是21的因数。数字12的因数有2和6,也有3和4.每个数字的因数都有1和它本身，数字1和21是21的因数，数字1
和12是12的因数。这是因为1乘以任何数字总是得到相同的数字。但如果那个数字没有其他因数，那么那个数字就是质数。

以下列出一些质数（注意，1不被看做质数）：

2、3、5、7、11、13、17、19、23、29、31、37、41、43、47、53、59、61、67、71、73、79、83、89、97、101、103、107、109、113、127、131、137、139、149、151、157、163、167、173、179、181、191、193、197、199、211、223、227、229、233、239、241、251、257、263、269、271、277、281……无穷无尽

质数有无穷多个，这意味着没有“最大”质数。它们只会越来越大，就像普通数字一样。RSA加密法的密钥使用非常大的质数。因此，密钥太多而不能暴力破译。

Googol是1后跟100个0的数字：

10 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000

（一点历史：搜索引擎公司Google 的名字源自错误拼写“googol”，但他们发现他们更喜欢现在这个拼写，于是决定保留它。）

十亿个十亿个十亿个Googol比Googol多27个0：

10 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000

但这些都是小数字。我们的RSA程序通常使用的质数都有上百个数位：

112 829 754 900 439 506 175 719 191 782 841 802 172 556 768 253 593 054 977 186 2355 84 979 780 304 652 423 405 148 425 447 063 090 165 759 070 742 102 132 335 103 295 947 000 718 386 333 756 395 799 633 478 227 612 244 071 875 721 006 813 307 628 061 280 861 610 153 485 352 017 238 548 269 452 852 733 818 231 045 171 038 838 387 845 888 589 411 762 622 041 204 120 706 150 518 465 720 862 068 595 814 264 819

以上数字很大，我猜你甚至部会去看它里面有没有输入错误。

## 合数

不是质数的整数叫做**合数**，因为除了1和这个数字本身至少还有两个因数可以合成它们。它们之所以叫做合数，是因为这些数字是由质数相乘来合成的，例如，合数1386是由2 * 3 * 3 * 7 * 11相乘合成的。

以下列出4个关于质数的事实：

1. 质数是大于1且因数只有1和它们自己的整数
2. 2是唯一的偶数质数（我觉得这使2成为一个非常奇特的质数）。
3. 质数有无穷多个。没有”最大质数“。
4. 两个质数相乘得到的数字只有两组因数，1和它本身（就像其他数字一样），相乘的两个质数。比如说，3和7都是质数。3乘以7得21.21的因数只有1、21、3和7.

## 质数筛选模块的源代码

我们先创建一个模块，里面包含和质数相关的函数：

* isPrime()会返回True或False，表示传给它的数字是不是质数。它会使用”除法测试“算法。
* primeSieve()会使用”埃拉托色尼筛选“算法（稍后讲解）来生成数字。

和cryptomath.py一样，primeSieve.py程序只是作为模块导入其他程序，它在自己运行时不做任何事情。

    
    import math
    
    def isPrime(num):
        # Return True if num is a prime number, otherwise False.
        # Note: Generally, isPrime() is slower than primeSieve().
        if num < 2:
            return False
    
        # see if num is divisible by any number up to the square root of num
        for i in range(2, int(math.sqrt(num)) + 1):
            if num % i == 0:
                return False
    
        return True
    
    
    def primeSieve(sieveSize):
        # Returns a list of prime numbers calculated using
        # the Sieve of Eratosthenes algorithm
        sieve = [True] * sieveSize
        # zero and one are not prime numbers
        sieve[0] = False
        sieve[1] = False
    
        # create the sieve
        for i in range(2, int(math.sqrt(sieveSize)) + 1):
            pointer = i * 2
            while pointer < sieveSize:
                sieve[pointer] = False
                pointer += i
    
        # compile the list of primes
        primes = []
        for i in range(sieveSize):
            if sieve[i]:
                primes.append(i)
    
        return primes
    
##  如何判断一个数字是不是质数

质数除了1和它本身没有其他因数。因此，要判断一个数字是不是质数，我们只要一直将它除以一些整数，看看它们之中有没有可以整除这个数字，余数为0的。

math.sqrt()函数将返回一个浮点数，表示传给它的数字的平方根。一个数字的平方根可以和它自身相乘得到这个数字。如49的平方根是7，因为7 × 7得49。

要判断49是不是质数，将它除以从2开始的整数：

    49 ÷ 2 = 24余数1
    
    49 ÷ 3 = 16余数1
    
    49 ÷ 4 = 12余数1
    
    49 ÷ 5 = 9余数4
    
    49 ÷ 6 = 8余数1
    
    49 ÷ 7 = 7余数0
    
事实上，你只需将这个数字除以质数，没有必要去判断6能否除49，因为如果它能除，那么2也将能除49，因为2是6的因数。任何6能整除的数字，2也能整除。

![](http://p1.bpimg.com/1949/1b029ae8fd397b61.png)

因为有一个整数（除了1和49）能整除49（也就是说，余数为0），所以我们知道49不是质数。再举一个例子，我们试试13：


    13 ÷ 2 = 6余数1
    
    13 ÷ 3 = 4余数1
    
    13 ÷ 4 = 3余数1
    
没有整数除13的余数为0（除了1和13，它们不算）。事实上，我们甚至不用除以13以内的所有数字。我们只要测试目标数字的平方根以内（包括这个平方根）的整数就行了。一个数字的平方根是乘以自身得到第一个数字的数字。25的平方根是5，因为5 × 5 = 25。13的平方根大约是3.6055512754639，因为3.6055512754639 × 3.6055512754639 = 13。这意味着，当我们判断13是不是质数时，我们只要除以2和3就行了，因为4大于13的平方根。

## 埃拉托色尼筛选法

埃拉托色尼筛选法（The Sieve of Eratosthenes）是一个计算质数的算法。假设有一组方框装着每个整数，所有整数都标记为“质数”

![](http://p1.bpimg.com/1949/5683ecdb8597355f.png)

把1标记为”非质数“（因为1不是质数）。然后，把所有2的倍数（除了2本身）标记为”非质数“.这意味着我们会把4(2 * 2)、6(2 * 3)、（2 × 4）、10、12等整数全部标记为”非质数“，直到50为止（我们拥有的最大数字）。

接着，重复这个过程，把3的所有倍数标记为”非质数“，除了3本身：6、9、12、15、18、21等。接着，对4的所有倍数（除了4本身）和5的所有倍数（除了5本身）做同样的事情，直到8为止。我们之所以在8停下来是因为它大于7.071，也就是50的平方根。我们可以这样做是因为9、10、11等的倍数都已经标记了。


通过埃拉托色尼筛选法，我们计算出50以内的质数是2、3、5、7、11、13、17、19、23、29、31、37、41、43和47。当我们希望快速找出特定区间里的所有质数时，这个筛选算法就很有用了。相比之前使用“除法测试”来测试2是不是质数，然后测试3是不是质数，接着测试4是不是质数等，它要更快。

## 检测质数

primeSieve.py里的isPrime()函数判断一个数字能否被2和这个数字的平方根之间的数字整除。但1 070 595 206 942 983这种数字呢？如果你把这个整数传给isPrime()，需要数秒才能判断它是不是质数。如果某个数字有数百个数位（就像下一节的RSA程序的质数那样），将要超过一万亿年才能判断这一个数字是不是质数。

primeSieve.py里的isPrime()函数对于我们将在RSA加密法里使用的大数来说太慢了。幸运的是，有一个叫做拉宾米勒质数测试（The Rabin-Miller Primality Test）的算法可以判断这么大的数字是不是质数。我们将在rabinMiller.py里利用更好的算法来创建一个新的isPrime()函数。

##  拉宾米勒模块的源代码

    import random
    
    
    def rabinMiller(num):
        # Returns True if num is a prime number.
    
        s = num - 1
        t = 0
        while s % 2 == 0:
            # keep having s while is is event( and use t
            # to count how many times we halve s)
            s = s // 2
            t += 1
    
        for trials in range(5): # try to falsify num's primality 5 times
            a = random.randrange(2, num - 1)
            v = pow(a, s, num)
            if v != 1:
                # this test does not apply if v is 1.
                i = 0
                while v != (num - 1):
                    if i == t - 1:
                        return False
                    else:
                        i = i + 1
                        v = (v ** 2) % num
        return True
    
    def isPrime(num):
        # Return True if num is a prime number. This function does a quicker
        # prime number check before calling rabinMiller().
    
        if num < 2:
            return False
    
        lowPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]
    
        if num in lowPrimes:
            return True
    
        for prime in lowPrimes:
            if num % prime == 0:
                return False
    
        return rabinMiller(num)
    
    
    def generateLargePrime(keysize=1024):
        while True:
            num = random.randrange(2**(keysize - 1), 2 **(keysize))
            if isPrime(num):
                return num


## 拉宾米勒算法


拉宾米勒算法的主要优势是它是一个相对简单的质数测试，在一台普通计算机上运行只要数秒时间。

## 小结

质数在数学里有着令人着迷的特性。你将在下一节里了解到，它们也是专业加密软件实际使用的加密法的基石。质数的定义很简单：一个数字的因数只有1和它本身。但判断哪些数字是质数，哪些是合数（也就是非质数）需要更智能的代码。

将一个数字对2和这个数字的平方根之间的所有数字取模是我们的isPrime()函数判断那个数字是不是质数的方法。质数对任何数字（除了它的因数，1和它本身）取模，余数都不会是0。但在测试较大数字是不是质数时，计算机可能需要一些时间。

埃拉托色尼筛选法可以用来快速判断一个范围的数字是不是质数，但需要大量内存。

RSA加密法利用非常大的质数，它们有数百个数位长。primeSieve.py里的埃拉托色尼筛选法和简单的isPrime()函数不足以处理这么大的数字。

拉宾米勒算法利用了一些数学知识，它的代码很简单（但其背后的数学理论对于本书来说太复杂了），却允许我们判断有数百个数位长的数字是不是质数。

在下一节里，我们将在RSA加密法程序里使用我们给rabinMiller.py开发的质数代码。最终，我们将得到一个加密法，它比一次一密加密法更易使用，但无法使用本书里的简单破译技术来破译！